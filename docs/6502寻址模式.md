# 寻址模式

寻址, 顾名思义 **寻找地址**.

    工作模式如下：
    从程序寄存器（register[pc])读取数据，获得指令
    寄存器指向下一个地址
    寻址模式决定该指令需要后面几个字节的数据
    如果需要0个，那指令包含了数据，直接执行指令即可。此时pc已经指向下一条指令
    如果需要1个，那么读取当前字节数据，执行指令。读取数据后应将pc指向下一个地址，
        该地址为指令
    如果需要2个，以此类推读取接下来2个字节，执行指令。读取完毕后将pc指向下一个地址。
        注意，读取2字节数据时有大小端，关系到如何解释两个字节。
    更多可以类推
    
寻址方式就是处理器根据指令中给出的地址信息来寻找有效地址的方式，
是确定本条指令的数据地址以及下一条要执行的指令地址的方法

获取操作码 伪C代码:
    
   ```
    opcode = READ(pc);
    pc++;
    
   ```

0.  **累加器寻址** Accumulator  
    操作对象是累加器, 个人认为可以被划分至下面一条**隐含寻址**, 只是语法稍微不同
    
    ```
    $0A
    ASL A - (累加器A内容按位算术左移1位)
    ```
    
    **指令伪C代码**
    ```
    // 空
    ```
    
    
1.  **隐含寻址** Implied Addressing  
    单字节指令, 指令已经隐含了操作地址
    
    ```
    $AA
    TAX - (将累加器中的值传给 X 寄存器, 即 X = A)
    
    ```
    
    **指令伪C代码**
    
    // 空
    
2.  **立即寻址** Immediate Addressing  
    双字节指令, 指令的操作数部分给出的不是 操作数地址而是操作数本身,我们称为立即数(00-FF之间的任意数)  
    在6502汇编中，这种模式以操作数(即**立即数**)前加 "#" 来标记.
    
    ```
    $A9 $0A
    LDA #$0A - (将内存值$0A载入累加器, 即 A = 0x0A)
    
    ```
    
    **指令伪C代码**
    
    // 指令计数器的地址即为当前需要读取的地址
    address = pc;
    // 双字节指令(获取操作码已经+1)
    pc++;
    
3.  **绝对寻址** Absolute Addressing 又称**直接寻址**  
    三字节指令, 指令的操作数给出的是操作数, 在存储器中的有效地址
    
    ```
    $AD $F6 $31
    LDA $31F6 - (将地址为$31F6的值载入累加器, 即 A = [$31F6])
    
    ```
    
    **指令伪C代码**
    ```
    // PC指向的两个字节解释为地址
    address = READ(pc++);
    address |= READ(pc++) << 8;
    ```
    
4.  **零页寻址** 全称**绝对零页寻址** Zero-page Absolute Addressing  
    双字节指令, 将地址$00-$FF称之为**零页**, 绝对寻址中如果高字节为0, 即可变为零页寻址, 
    直接能够节约一个字节, 速度较快, 所以经常使用的数据可以放在零页.
    
    ```
    $A5 $F4
    LDA $F4 - (将地址为$00F4的值载入累加器, 即 A = *0x00F4)
    
    ```
    
    **指令伪C代码**
    ```
    // PC指向的一个字节解释为地址
    address = READ(pc++);
    ```
5.  **绝对X变址** Absolute X Indexed Addressing  
    三字节指令, 这种寻址方式是将一个16位的直接地址作为基地址, 然后和变址寄存器X的内容相加, 结果就是真正的有效地址
    
    ```
    $DD $F6 $31
    LDA $31F6, X - (将值$31F6加上X作为地址的值载入累加器, 即 A = 0x31F6[X])
    
    ```
    
    **指令伪C代码**
    ```
    // PC指向的两个字节解释为基地址
    address = READ(pc++);
    address |= READ(pc++) << 8;
    // 加上X变址寄存器
    address += X;
    ```
6.  **绝对Y变址** Absolute Y Indexed Addressing  
    三字节指令, 同5, 就是把X换成Y而已
    
    **指令伪C代码**
    ```
    // PC指向的两个字节解释为基地址
    address = READ(pc++);
    address |= READ(pc++) << 8;
    // 加上Y变址寄存器
    address += Y;
    ```
    
7.  **零页X变址** Zero-page X Indexed Addressing  
    双字节指令, 同5, 如果高地址是0, 可以节约一个字节.
    
    **指令伪C代码**
    ```
    // PC指向的一个字节解释为零页基地址
    address = READ(pc++);
    // 加上X变址寄存器
    address += X;
    // 结果在零页
    address = address & 0xFF;
    ```
8.  **零页Y变址** Zero-page Y Indexed Addressing  
    双字节指令, 同7, 就是把X换成Y而已
    
    **指令伪C代码**
    ```
    // PC指向的一个字节解释为零页基地址
    address = READ(pc++);
    // 加上Y变址寄存器
    address += Y;
    // 结果在零页
    address = address & 0xFF;
    ```
9.  **间接寻址** Indirect Addressing  
    三字节指令, 在 6502中,仅仅用于无条件跳转指令`JMP`这条指令该寻址方式中, 操作数给出的是间接地址, 间接地址是指存放操作数有效地址的地址
    
    ```
    $6C $5F $21
    JMP ($215F)  - 跳转至$215F地址开始两字节指向的地址
    
    ```
    
    有点拗口, 假如:
    
    地址|值
    ---|---
    $215F|$76
    $2160|$30
    
    这个指令将获取 $215F, $2160 两个字节中的值，然后把它当作转到的地址 - 也就是跳转至$3076
    
    **已知硬件BUG/缺陷**
    
    这唯一一个用在一条指令的寻址方式有一个已知的BUG/缺陷: `JMP ($xxFF)`无法正常工作.
    
    例如`JMP ($10FF)`, 理论上讲是读取$10FF和$1100这两个字节的数据, 但是实际上是读取的$10FF和$1000这两个字节的数据. 虽然很遗憾但是我们必须刻意实现这个BUG, 这其实算是实现FC模拟器中相当有趣的一环.
    
    **指令伪C代码**
    ```
    // PC指向的两个字节解释为间接地址
    tmp1 = READ(pc++);
    tmp1 |= READ(pc++) << 8;
    // 刻意实现6502的BUG
    tmp2 = (tmp1 & 0xFF00) | ((tmp1+1) & 0x00FF)
    // 读取间接地址
    address = READ(tmp1) | (READ(tmp2) << 8);
    ```
10.  **间接X变址**(先变址X后间接寻址): Pre-indexed Indirect Addressing  
    双字节指令, 比较麻烦的寻址方式
    
    ```
    $A1 $3E
    LDA ($3E, X)
    
    ```  
     这种寻址方式是先以X作为变址寄存器和零页基地址IND(这里就是$3E)相加`IND+X`, 不过这个变址计算得到的只是一个间接地址,还必须经过两次间接寻址才得到有效地址:
     ```
     *   第一次对 IND + X 间址得到有效地址低 8 位
     *   第二次对 IND + X + 1 间址得到有效地址高 8 位
     *   然后把两次的结果合起来,就得到有效地址.
     ```
    例如:

    地址 | 值  
      ---| ---   
     X | $05
     $0043 | $15
    $0044 |$24
    $2415 |$6E

    这条指令将被如下执行:
    ```
    *   $3E + $05 = $0043
    *   获取 $0043, $0044 两字节中保存的地址 = $2415
    *   读取 $2415 中的内容 - $6E
    *   执行LDA, 把值$6E载入累加器
    ```
    
    **指令伪C代码**

    ```
    // PC指向的一个字节解释为零页基地址再加上X寄存器
    tmp = READ(pc++) + X;
    // 读取该零页地址指向的两个字节
    address = READ(tmp) | (READ(tmp + 1) << 8);
    ```
    
11.  **间接Y变址**(后变址Y间接寻址): Post-indexed Indirect Addressing  
    双字节指令, 比较麻烦的寻址方式
    
    ```
    $B1 $4C
    LDA ($4C), Y
    
    ```
    
        *   这种寻址方式是对IND(这里就是$4C)部分所指出的零页地址先做一次间接寻址, 得到一个低8位地址
        *   再对IND + 1 作一次间接寻址,得到一个高8位地址
        *   最后把这高,低两部分地址合起来作为16的基地址,和寄存器Y进行变址计算, 得到操作数的有效地址,注意的是这里IND是零页地址
        
    例如:
    
    地址 | 值
    ---  | ---
    $004C|$00
    $004D|$21
    Y    |$05
    $2105|$6D
    
    这条指令将被如下执行:
    
        *   读取字节 $4C, $4D 中的内容 = $2100
        *   Y 寄存器中的内容相加 = $2105
        *   读取字节 $2105 中的内容 - $6D
        *   执行LDA, 把值$6D载入累加器
    
    **指令伪C代码**
    ```
    // PC指向的一个字节解释为零页地址
    tmp = READ(pc++);
    // 读取该零页地址指向的两个字节作为基地址
    address = READ(tmp) | (READ(tmp + 1) << 8);
    // 基地址再加上Y寄存器
    addres += Y;
    ```
    
12.  **相对寻址**: Relative Addressing  
    该寻址仅用于条件转移指令, 指令长度为2个字节.  
    第1字节为操作码,第2字节为条件转移指令的跳转步长, 又叫偏移量D. 偏移量可正可负, D若为负用补码表示.
    
    ```
    $F0 $A7
    BEQ $A7 - (如果标志位中'Z'-被设置, 则向后跳转-39字节, 即前跳39字节)
    
    ```
     **指令伪C代码**
    ```
    // 读取操作数
    tmp = READ(pc++);
    // PC加上有符号数据即可
    address = pc + (int8\_t)tmp;
    注意, 这里并没有进行条件判断
    ```
